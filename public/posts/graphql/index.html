<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>graphQL | a tech.stuff blog</title>
<meta name="keywords" content="">
<meta name="description" content="Intro Idea Is a language for interaction with graph based data models, tunneled via HTTP-Post. Allows to query and change (mutate) data.
Allows an recursive selection of desired nodes and properties.
As a client i am able to tell exactly what i expect. There are some standards for navigation through a huge result sets via pagination. It offers a subscription functionality for recognize changes. Also a lot of tools are available for different functionalities for the client as well as for the server side.">
<meta name="author" content="Jenka">
<link rel="canonical" href="https://jenkawitzig.github.io/blog/posts/graphql/">
<link crossorigin="anonymous" href="/blog/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/blog/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://jenkawitzig.github.io/blog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://jenkawitzig.github.io/blog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://jenkawitzig.github.io/blog/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://jenkawitzig.github.io/blog/apple-touch-icon.png">
<link rel="mask-icon" href="https://jenkawitzig.github.io/blog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="graphQL" />
<meta property="og:description" content="Intro Idea Is a language for interaction with graph based data models, tunneled via HTTP-Post. Allows to query and change (mutate) data.
Allows an recursive selection of desired nodes and properties.
As a client i am able to tell exactly what i expect. There are some standards for navigation through a huge result sets via pagination. It offers a subscription functionality for recognize changes. Also a lot of tools are available for different functionalities for the client as well as for the server side." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jenkawitzig.github.io/blog/posts/graphql/" /><meta property="article:section" content="posts" />



<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="graphQL"/>
<meta name="twitter:description" content="Intro Idea Is a language for interaction with graph based data models, tunneled via HTTP-Post. Allows to query and change (mutate) data.
Allows an recursive selection of desired nodes and properties.
As a client i am able to tell exactly what i expect. There are some standards for navigation through a huge result sets via pagination. It offers a subscription functionality for recognize changes. Also a lot of tools are available for different functionalities for the client as well as for the server side."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://jenkawitzig.github.io/blog/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "graphQL",
      "item": "https://jenkawitzig.github.io/blog/posts/graphql/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "graphQL",
  "name": "graphQL",
  "description": "Intro Idea Is a language for interaction with graph based data models, tunneled via HTTP-Post. Allows to query and change (mutate) data.\nAllows an recursive selection of desired nodes and properties.\nAs a client i am able to tell exactly what i expect. There are some standards for navigation through a huge result sets via pagination. It offers a subscription functionality for recognize changes. Also a lot of tools are available for different functionalities for the client as well as for the server side.",
  "keywords": [
    
  ],
  "articleBody": "Intro Idea Is a language for interaction with graph based data models, tunneled via HTTP-Post. Allows to query and change (mutate) data.\nAllows an recursive selection of desired nodes and properties.\nAs a client i am able to tell exactly what i expect. There are some standards for navigation through a huge result sets via pagination. It offers a subscription functionality for recognize changes. Also a lot of tools are available for different functionalities for the client as well as for the server side. As a client, there are tools for caching or offline availability (local caching after pulling from a server, update notification). Serverside tools mostly for enabling the usage of other things, like bridging to existing APIs or databases.\nNative query syntax, JSON output.\nBuckets…again As with HTTP, the concept of semantic buckets is a good approach to establishing re-usability in graphQL. Hence we find three concepts:\nquery mutation subscription. Query contains things like get_X(), find_Y() or list_Z(). initiate(), submit(), update() or cancel() belongs to the mutattion bucket und subscription is something like getNewInfos().\nWhen to use it… … imho only when you accesing your graph based data in unforeseen way and your server is almost a kind of a data store\nNays… Leads to a amount of client side logic, if ypu still have server side business logic (and your server isn’t only a data storage), graphQL is not your friend You will have a tight coupling between your client and your data Let me explain this: The naturally functionality of a client is containing one sort of logic: the presentation logic. With graphQL your queries encapsulated a lot of business logic, too. This adds another kind of logic to the client: Business logic. The client tended to be a rich one. These, now, two functionalities of your client doesn’t stick that much together like teh business logic and the base data. Hence the client is much tighter coupled to the data than it’s second functionality, the presentation logic. R.I.P SoC :( Adding tools over tools to server for using something blow up your server complexity Sending high complex queries to your server and your server needs much more resources to solve this than planned? ouch… there is a risk to kill your server with your client ",
  "wordCount" : "380",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Jenka"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://jenkawitzig.github.io/blog/posts/graphql/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "a tech.stuff blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://jenkawitzig.github.io/blog/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://jenkawitzig.github.io/blog/" accesskey="h" title="a tech.stuff blog (Alt + H)">a tech.stuff blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://jenkawitzig.github.io/blog/" title="a tech.stuff blog">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://jenkawitzig.github.io/blog/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://jenkawitzig.github.io/blog/about/" title="Abouts">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      graphQL
    </h1>
    <div class="post-meta">Jenka

</div>
  </header> 
  <div class="post-content"><h2 id="intro">Intro<a hidden class="anchor" aria-hidden="true" href="#intro">#</a></h2>
<h2 id="idea">Idea<a hidden class="anchor" aria-hidden="true" href="#idea">#</a></h2>
<p>Is a language for interaction with graph based data models, tunneled via HTTP-Post. Allows to query and change (mutate) data.</p>
<p>Allows an recursive selection of desired nodes and properties.</p>
<p>As a client i am able to tell exactly what i expect.
There are some standards for navigation through a huge result sets via pagination. It offers a subscription functionality for recognize changes.
Also a lot of tools are available for different functionalities for the client as well as for the server side. As a client, there are tools for caching or offline availability (local caching after pulling from a server, update notification). Serverside tools mostly for enabling the usage of other things, like bridging to existing APIs or databases.</p>
<p>Native query syntax, JSON output.</p>
<h2 id="bucketsagain">Buckets&hellip;again<a hidden class="anchor" aria-hidden="true" href="#bucketsagain">#</a></h2>
<p>As with HTTP, the concept of semantic buckets is a good approach to establishing re-usability in graphQL. Hence we find three concepts:</p>
<ul>
<li>query</li>
<li>mutation</li>
<li>subscription.</li>
</ul>
<p>Query contains things like <code>get_X()</code>, <code>find_Y()</code> or <code>list_Z()</code>. <code>initiate()</code>, <code>submit()</code>, <code>update()</code> or <code>cancel()</code> belongs to the mutattion bucket und subscription is something like <code>getNewInfos()</code>.</p>
<h3 id="when-to-use-it">When to use it&hellip;<a hidden class="anchor" aria-hidden="true" href="#when-to-use-it">#</a></h3>
<p>&hellip; imho only when you accesing your graph based data in <em>unforeseen</em> way and your server is almost a kind of a data store</p>
<h3 id="nays">Nays&hellip;<a hidden class="anchor" aria-hidden="true" href="#nays">#</a></h3>
<ul>
<li>Leads to a amount of client side logic, if ypu still have server side business logic (and your server isn&rsquo;t only a data storage), graphQL is not your friend</li>
<li>You will have a tight coupling between your client and your data <!-- raw HTML omitted --> <!-- raw HTML omitted --> <em>Let me explain this:</em> <!-- raw HTML omitted --> The naturally functionality of a client is containing one sort of logic: the presentation logic. With graphQL your queries encapsulated a lot of business logic, too. This adds another kind of logic to the client: Business logic. The client tended to be a rich one. These, now, two functionalities of your client doesn&rsquo;t stick that much together like teh business logic and the base data. Hence the client is much tighter coupled to the data than it&rsquo;s second functionality, the presentation logic. <!-- raw HTML omitted --> R.I.P SoC :(</li>
<li>Adding tools over tools to server for using <em>something</em> blow up your server complexity</li>
<li>Sending high complex queries to your server and your server needs much more resources to solve this than planned? ouch&hellip; there is a risk to kill your server with your client</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://jenkawitzig.github.io/blog/">a tech.stuff blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
